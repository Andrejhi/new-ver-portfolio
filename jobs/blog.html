<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Блог в статьях</h1>
    <a href="index.html">Home</a>
    <ul>
        <li><a href="#">Технологии</a></li>
    </ul>
    <aside>
        <h2>Ненормальная криптография, или как я проверял подписи Ed25519 на Solidity</h2>
        <p><a href="#"></a><span><a href="#">Блог компании Near,</a>
            <a href="#">Ненормальное программирование, </a>
            <a href="#">Криптография, </a>
            <a href="#">Solidity, </a>
            <a href="#">Криптовалюты </a></span></p>
            <p>Когда пишут о том, как разрабатывать безопасные приложения, один из частых советов звучит так: не пишите
                 криптографию самостоятельно, а используйте какую-нибудь проверенную библиотеку. К сожалению, при разработке
                  блокчейнов этот совет часто не работает: нужные алгоритмы либо не реализованы вовсе, либо существующие
                   реализации не годятся по множеству возможных причин — даже потому, что они недостаточно безопасны. Вот
                    и в этом случае нужно было проверять подписи, использующие Ed25519 — весьма популярный тип подписей,
                     для которого существует множество реализаций, ни одна из которых, однако, нам не подошла. А всё потому,
                      что проверка должна была выполняться из смарт-контракта, работающего на блокчейне Ethereum.</p>

            <p>Что такое смарт-контракт</p>
            <p>Смарт-контракт — это специальная программа, которая в некотором смысле выполняется «внутри блокчейна». 
                Технически это реализовано так: каждый узел, поддерживающий блокчейн, выполняет код смарт-контракта и 
                проверяет, что результат выполнения, записанный в блокчейне, совпадает с ожидаемым. В результате смарт-
                контракты обеспечивают намного более высокий уровень безопасности для критических вычислений: в то время
                 как для того, чтобы изменить результат работы обычной программы, достаточно взломать только тот компьютер,
                  на котором она выполняется, для вмешательства в смарт-контракт необходимо взять под контроль бо́льшую 
                  часть узлов. Если какой-то один узел выполнит смарт-контракт неправильно, другие узлы не примут его 
                  результат. Благодаря механизму голосования, в итоге в блокчейне останется тот результат, на котором 
                  сошлось большинство узлов.</p>
            <p>В чём же проблема?</p>
            <p>В Ethereum смарт-контракты выполняются в специальном окружении — так называемой виртуальной машине Ethereum
                 (Ethereum virtual machine, EVM).</p>
            <p>Что такое EVM?</p>
            <p>EVM — абстрактная виртуальная машина, специально разработанная для выполнения смарт-контрактов. Одним из
                 критически важных требований к ней является повторяемость: любая без исключения программа, будучи выполненной
                  с одинаковыми входными данными, должна гарантированно вернуть одинаковый результат — вне зависимости от 
                  реализации виртуальной машины, аппаратной архитектуры или любых других внешних факторов. Это необходимо, 
                  потому что иначе возможна ситуация, когда разные узлы получат разный результат при выполнении одного и того
                   же смарт-контракта, что приведёт к нарушению работы сети.</p>
            <p>EVM разработана, чтобы быть простой в реализации, но ценой этого является низкая эффективность. Кроме того, все
                 вычисления на блокчейне повторяются всеми узлами, поэтому стоимость этих вычислений на порядки больше, чем, 
                 например, стоимость вычислений на облачном сервере. По этой причине смарт-контракты приходится тщательно опти
                 мизировать. Поскольку EVM существенно отличается от окружения, в котором работает большинство программ, программы,
                 написанные на обычных языках программирования, не работают в EVM. Если бы обычные языки и допускали трансляцию в
                  EVM-байткод, из-за различий архитектуры код практически любой реализации Ed25519 был бы слишком неэффективен — 
                  настолько, что ресурсов, выделяемых на обработку одной транзакции, не хватило бы даже, чтобы проверить одну 
                  подпись. Вместо них, для EVM разработано несколько специальных языков, и самый популярный из них — Solidity.</p>



            <p>EVM существенно отличается как от популярных процессорных архитектур, так и от часто используемых абстрактных 
                виртуальных машин, таких как JVM или WASM. В то время как большинство архитектур содержат операции для работы
                 с 32- и 64-битными числами, в EVM единственный тип данных — 256-битное целое число. Для реализации Ed25519 это
                  очень удобно, так как все необходимые вычисления производятся над числами, помещающимися в 256 бит.</p>
            <p></p>
            <p></p>
            <p></p>
            <p></p>
            <p></p>
            <p></p>
            <p></p>
            <ul>
                <li><button>3</button></li>
                <li><button>3</button></li>
                <li><button>3</button></li>
                <li><button>3</button></li>
                <li><button>Поделиться</button></li>
            </ul>

    </aside>
</body>
</html>